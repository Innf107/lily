let ℕ : Type = (a : Type) -> a -> (a -> a) -> a 
in

let 0 : ℕ = λa. λz. λs. z
in

let S : ℕ -> ℕ = λn. λa. λz. λs. s (n a z s)
in

let 1 : ℕ = S 0 in
let 2 : ℕ = S 1 in
let 3 : ℕ = S 2 in
let 4 : ℕ = S 3 in
let 5 : ℕ = S 4 in

let add : ℕ -> ℕ -> ℕ = 
    λn. λm. n ℕ m S
in

let Eq : (k : Type) -> k -> k -> Type =
    λk. λa. λb. (f : k -> Type) -> f a -> f b
in

let Refl : (k : Type) -> (a : k) -> Eq k a a =
    λk. λa. λf. λfa. fa
in

let Symm : (k : Type) -> (a : k) -> (b : k) 
         -> Eq k a b 
         -> Eq k b a =
    λk. λa. λb. λAeB. AeB (λd. Eq k d a) (Refl k a)
in

let Trans : (k : Type) -> (a : k) -> (b : k) -> (c : k)
          -> Eq k a b 
          -> Eq k b c
          -> Eq k a c =
    λk. λa. λb. λc. λAeB. λBeC.
        BeC (Eq k a) AeB
in

let test : Eq ℕ (add 2 3) 5 = Refl ℕ 5 in

let abs0PlusL : (n : ℕ) -> Eq ℕ (add 0 n) n =
    λn. Refl ℕ n
in

-- let indℕ : (P : ℕ -> Type) -> P 0 -> ((n : ℕ) -> P n -> P (S n)) -> (m : ℕ) -> P m = 
--     λp. λp0. λpInd. λm. _ 
-- in

-- This needs induction over naturals. No idea how to do that with church naturals.
-- Guess I'll have to add inductive types now, don't I?
-- let abs0PlusR : (n : ℕ) -> Eq ℕ (add n 0) n =
--     λn. n 
--         _ 
--         _ 
-- in

let Either : Type -> Type -> Type = 
    λa. λb. (c : Type) -> (a -> c) -> (b -> c) -> c
in

let injl : (a : Type) -> (b : Type) -> a -> Either a b = 
    λa. λb. λx. λc. λelimL. λelimR. elimL x
in

let injr : (a : Type) -> (b : Type) -> b -> Either a b =
    λa. λb. λx. λc. λelimL. λelimR. elimR x
in

let Pair : Type -> Type -> Type =
    λa. λb. (c : Type) -> (a -> b -> c) -> c
in

let MkPair : (a : Type) -> (b : Type) -> a -> b -> Pair a b =
    λa. λb. λx. λy. λc. λf. f x y
in

let 𝟘 : Type = (a : Type) -> a
in

let ¬ : Type -> Type = λa. a -> 𝟘 in

let TripleNeg : (a : Type) -> ¬ (¬ (¬ a)) -> ¬ a = 
    λa. λf. λx. f (λg. g x)
in

Type
