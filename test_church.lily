let â„• : Type = (a : Type) -> a -> (a -> a) -> a 
in

let 0 : â„• = Î»a. Î»z. Î»s. z
in

let S : â„• -> â„• = Î»n. Î»a. Î»z. Î»s. s (n a z s)
in

let 1 : â„• = S 0 in
let 2 : â„• = S 1 in
let 3 : â„• = S 2 in
let 4 : â„• = S 3 in
let 5 : â„• = S 4 in

let add : â„• -> â„• -> â„• = 
    Î»n. Î»m. n â„• m S
in

let Bool : Type = (a : Type) -> a -> a -> a
in

let True : Bool =
    Î»a. Î»f. Î»t. t
in

let False : Bool =
    Î»a. Î»f. Î»t. f
in

let if : Bool -> (a : Type) -> a -> a -> a =
    Î»b. b
in


let Eq : (k : Type) -> k -> k -> Type =
    Î»k. Î»a. Î»b. (f : k -> Type) -> f a -> f b
in

let Refl : (k : Type) -> (a : k) -> Eq k a a =
    Î»k. Î»a. Î»f. Î»fa. fa
in

let Symm : (k : Type) -> (a : k) -> (b : k) 
         -> Eq k a b 
         -> Eq k b a =
    Î»k. Î»a. Î»b. Î»AeB. AeB (Î»d. Eq k d a) (Refl k a)
in

let Trans : (k : Type) -> (a : k) -> (b : k) -> (c : k)
          -> Eq k a b 
          -> Eq k b c
          -> Eq k a c =
    Î»k. Î»a. Î»b. Î»c. Î»AeB. Î»BeC.
        BeC (Eq k a) AeB
in

let test : Eq â„• (add 2 3) 5 = Refl â„• 5 in

let abs0PlusL : (n : â„•) -> Eq â„• (add 0 n) n =
    Î»n. Refl â„• n
in

let Either : Type -> Type -> Type = 
    Î»a. Î»b. (c : Type) -> (a -> c) -> (b -> c) -> c
in

let injl : (a : Type) -> (b : Type) -> a -> Either a b = 
    Î»a. Î»b. Î»x. Î»c. Î»elimL. Î»elimR. elimL x
in

let injr : (a : Type) -> (b : Type) -> b -> Either a b =
    Î»a. Î»b. Î»x. Î»c. Î»elimL. Î»elimR. elimR x
in

let Pair : Type -> Type -> Type =
    Î»a. Î»b. (c : Type) -> (a -> b -> c) -> c
in

let MkPair : (a : Type) -> (b : Type) -> a -> b -> Pair a b =
    Î»a. Î»b. Î»x. Î»y. Î»c. Î»f. f x y
in

let casePair : (a : Type) -> (b : Type) -> (c : Type) -> Pair a b -> (a -> b -> c) -> c =
    Î»a. Î»b. Î»c. Î»pair. Î»elim. pair c elim
in

let ðŸ˜ : Type = (a : Type) -> a
in

let Â¬ : Type -> Type = Î»a. a -> ðŸ˜ in

let TripleNeg : (a : Type) -> Â¬ (Â¬ (Â¬ a)) -> Â¬ a = 
    Î»a. Î»f. Î»x. f (Î»g. g x)
in

let pred : â„• -> â„• =
    Î»n. casePair Bool â„• â„•
        (n (Pair Bool â„•) (MkPair Bool â„• False 0) (Î»p.
            casePair Bool â„• (Pair Bool â„•) p
                (Î»initial. Î»m. if initial (Pair Bool â„•)
                    (MkPair Bool â„• True (S m))
                    (MkPair Bool â„• True m)
                )
        ))
        (Î»initial. Î»n. n)
in

let indâ„• : (P : â„• -> Type) -> P 0 -> ((n : â„•) -> P n -> P (S n)) -> (m : â„•) -> P m = 
    Î»P. Î»p0. Î»pIndHyp. Î»m. 
        m 
            (P m) 
            (unsafeCoerce# Type (P 0) (P m) p0) 
            (Î»pN. 
                let n : â„• = pred m in
                unsafeCoerce# Type (P (S n)) (P m) (pIndHyp n (unsafeCoerce# Type (P m) (P n) pN))
            )
in

let plusAbsR : (n : â„•) -> Eq â„• (add n 0) n =
    let P : â„• -> Type = Î»x. Eq â„• (add x 0) 0 in

    let p0 : P 0 = Refl â„• 0 in

    let pInd : (n : â„•) -> P n -> P (S n) = ?a in

    indâ„• P
        p0
        pInd
in

-- let addComm : (n : â„•) -> (m : â„•) -> Eq â„• (add n m) (add m n) =
--     Î»n. indâ„• (Î»x. Eq â„• x x) (Refl â„• n)
-- in

Type
